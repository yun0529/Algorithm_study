//// 0 -> 비트가 꺼져있다. 1 -> 비트가 켜져있다.
//// boolean 배열로 이진수를 저장
////  
//// shift 연산은 보통 1<< b 의 형태로만 사용된다.
//// a << b = a * 2^b
//// a >> b = a * (1/2)^b
////
//// 음수 표기 = 비트 반전 + 1
//// 
//// 
//// 
//// 
//// 
//#include <bits/stdc++.h>
//using namespace std;
//
//int main() {
//
//	int a = 9;
//	int b = 8;
//	cout << (a & b) << '\n'; // AND 연산 
//
//	cout << (a << b) << '\n'; // shift 연산 
//
//	cout << (9 ^ 10) << '\n'; // xor 연산 1001 xor 1010 = 0011
//
//	cout << ~3 << '\n'; // a ones' complement = -(a + 1);
//
//	// idx 번째 비트끄기
//	int S = 18; // 10010
//	int idx = 1;
//	S &= ~(1 << idx); // ~(00010) = 11101
//	cout << S << '\n'; // 10000
//
//	// idx 번째 비트 xor 연산
//	S = 18; // 10010
//	idx = 0;
//	S ^= (1 << idx); // 00001
//	cout << S << '\n'; // 10011
//
//	// 최하위 켜져있는 비트 찾기
//	S = 18; // 10010
//	idx = (S & -S); // 10010 & 101110
//	//S ^= (1 << idx); // 00001
//	cout << idx << '\n'; // 00010 = 2
//
//	// bool 배열을 대체할 수 있음.
//	// [1,1,1,1] -> 모두 true : 15
//	// (1 << n) - 1 : 크기 n인 집합에서 모든 비트가 켜지게 가능
//	int n = 5;
//	cout << (1 << n) - 1 << '\n';
//
//	// idx 번째 비트켜기
//	S = 18; // 10010
//	idx = 3; // 01000
//	S |= (1 << idx);
//	cout << S << '\n'; // 11010
//
//	// idx 번째 비트가 켜져있는지 확인하기
//	S = 18; // 10010
//	idx = 3; // 01000 , 10000
//	S &= (1 << idx);
//	cout << S << '\n'; // 00000, 10000 // if(S)로 확인 가능
//
//
//	return 0;
//}