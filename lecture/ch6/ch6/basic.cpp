// Graph
// 정점과 정점을 잇는 간선은 여러개일 수 있음.
// 가는 경로와 오는 경로의 수가 다를 수 있음 
// outdegree(나가는 간선)과 indegree(들어오는 간선)의 수가 다름을 의미
// 
// Tree
// 계층적 구조, 사이클 없음, 무방향 그래프
// 그래프의 하위 집합에 트리라는 특징을 가진 자료구조임.
// 임의의 두 노드의 경로는 유일무이하다.
// 문제 or 면접에서 트리 탐색이 있다면 루트부터 탐색하는 것이 좋다.
// 리프는 자식노드가 없다.
// 루트부터 특정 노드까지의 거리를 깊이라고 한다.
// level은 루트를 1 level이라고 하긴 하지만 문제마다 루트를 0 level이라고 하는 문제도 있음.
// 트리의 집합을 숲이라고 한다.
//
// Binary Tree
// 자식이 2개인 트리
// 정이진트리 : 자식노드가 0 또는 2인 이진 트리
// 완전 이진 트리 : 왼쪽부터 채워져 있는 이진 트리
// 변질 이진 트리 : 자식 노드가 하나밖에 없는 이진 트리 -> degenerate
// 포화 이진 트리 : 모든 노드가 꽉 차 있는 이진 트리
// 균형 이진 트리 : 모든 노드의 왼쪽 하위 트리와 오른쪽 하위 트리의 (높이) 차이가 1 이하인 이진 트리
// -> map, set을 구성하는 레드 블랙트리가 균형이진트리 중 하나이다.
// N = 15 , 높이 : 3 => O(logN) : 삽입, 삭제, 탐색
// map은 O(logN) : 삽입, 삭제, 탐색 를 보장 받는데 그 이유가 균형잡힌 레드블랙트리를 기반으로 하기 때문
// 
// 인접행렬
// 연결 리스트처럼 연결되어있다.
// 무방향 간선을 가짐 = 양방향 간선
// 그래프에서 정점과 간선의 관계를 나타내는 bool타입의 정사각형 행렬이다.
// 간선이 있다면 1을 간선이 해당하는 노드의 위치에 채움
// 1이 안채워진 다른 공간은 0 : 간선이 없다는것.
// 
// 인접리스트
// 연결리스트를 여러개 만들어서 리스트를 표현
// 정점마다 연결리스트를 만들어서 연결된 다른 노드를 넣음
// adj : 인접 리스트
// 
// 인접행렬 & 인접리스트 차이
// 공간 복잡도 : O(V^2) & O(V+E)
// 하나의 간선찾기 시간 복잡도 : O(1) & O(V)
// 모든 간선찾기 시간 복잡도 : O(V^2) & O(V+E)
// 조밀한(dense) 경우 인접 행렬, 간선이 별로 없을 때(sparse)는 인접 리스트 
// 
// 보통은 인접리스트를 쓰면 됨
// 코테나 면접 등에서는 인접행렬을 쓰는 것이 좋다.
// 
// 맵과 방향벡터
// 탐색
// dy[] = {-1, 0, 1, 0}
// dx[] = {0, 1, 0, -1}
// for문으로 탐색 가능
// ny = y + dy[i] 이런 식으로
// 
// 연결된 컴포넌트
// 연결된 하위 그래프를 말하며 연결된 하나의 덩어리다.
// 이 덩어리는 연결된 컴포넌트에 속한 모든 정점을 연결하는 경로가 있다.
// 리스트 형식이 아니라 행렬 형식으로 주어질 수 있음.
// 
// 

#include <bits/stdc++.h>
using namespace std;
const int V = 10;

//bool a[V][V], visited[V]; // 인접행렬 정의
//
//void go(int from) {
//	visited[from] = 1;
//	cout << from << '\n';
//	for (int i = 0;i < V;i++) {
//		if (visited[i])continue;
//		if (a[from][i]) {
//			go(i); //연결된 다른 정점이 있다면 다시 go 호출
//		}
//	}
//	return;
//}
//
//int main() {
//	//무방향 = 양방향 간선 표현
//	a[1][2] = 1; a[1][3] = 1; a[3][4] = 1;
//	a[2][1] = 1; a[3][1] = 1; a[4][3] = 1;
//	for (int i = 0; i < V;i++) {
//		for (int j = 0;j < V;j++) {
//			//if (a[i][j]) {
//			//	cout << i << "부터 " << j << "까지 경로가 있습니다.\n";
//			//	bfs(i);
//			//	dfs(i);
//			//}
//			if (a[i][j] && visited[i] == 0) { //간선이 있고 지나가지 않았다면
//				go(i);
//			}
//		}
//	}
//
//		
//
//	return 0;
//}

// 인접 리스트
//const int V2 = 4;
//vector<int> adj[V2]; // 인접 리스트 정의
//
//int main() {
//	adj[0].push_back(1);
//	adj[0].push_back(2);
//	adj[0].push_back(3);
//
//	adj[1].push_back(0);
//	adj[1].push_back(1);
//
//	adj[2].push_back(0);
//	adj[2].push_back(1);
//
//	adj[3].push_back(0);
//	for (int i = 0; i < 4;i++) {
//		cout << i << " :: ";
//		for (int there : adj[i]) {
//			cout << there << " ";
//		}
//		cout << '\n';
//	}
//
//	for (int i = 0;i < 4;i++) { // 이렇게도 할 수 있음. 
//		cout << i << " :: ";
//		for (int j = 0;j < adj[i].size();j++ ) {
//			cout << adj[i][j] << " ";
//		}
//		cout << '\n';
//	}
//
//	return 0;
//}

// 시계방향으로 탐색
// 4방향이 아니라 여덟 방향이더라도 동일한 방식으로 크기가 8인 배열을 사용
//const int dy[] = { -1, 0, 1, 0 };
//const int dx[] = { 0, 1, 0, -1 };
//const int n = 100;
//int arr[n][n];
//int visited[n][n];
//
//void go(int y, int x) {
//	visited[y][x] = 1;
//	cout << y << " : " << x << '\n';
//	for (int i = 0;i < 4;i++) {
//		int ny = y + dy[i];
//		int nx = x + dx[i];
//
//		if (ny < 0 || ny > n || nx < 0 || nx >= n)continue; // 배열의 범위 밖은 갈 수 없음
//		if (arr[ny][nx] == 0) continue; // 0은 갈 수 없음
//		if (visited[ny][nx]) continue; // 이미 방문했다면 못감
//		go(ny, nx); //연결된 다른 정점이 있다면 다시 go 호출
//			
//	}
//	return;
//}
//
//int main() {
//	int y = 0, x = 0;
//	for (int i = 0;i < 4;i++) {
//		int ny = y + dy[i];
//		int nx = x + dx[i];
//		cout << ny << " : " << nx << '\n';
//	}
//
//	return 0;
//}